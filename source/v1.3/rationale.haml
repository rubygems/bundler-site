#intro
  If you just want to know our recommended workflow, and don't care about the rationale, feel
  free to jump to the summary below.
%br

#standalone
  %h2#bundlers-purpose-and-rationale
    Bundler's Purpose and Rationale
  %p
    First, you declare these dependencies in a file at the root of your application, called
    <code>Gemfile</code>. It looks something like this:

  :highlight_ruby
    source 'https://rubygems.org'

    gem 'rails', '3.0.0.rc'
    gem 'rack-cache'
    gem 'nokogiri', '~> 1.4.2'

  %p
    This <code>Gemfile</code> says a few things. First, it says that bundler should look for gems
    declared in the <code>Gemfile</code> at <code>http://rubygems.org</code>. You can declare
    multiple Rubygems sources, and bundler will look for gems in the order you declared the
    sources.

  %p
    Next, you declare a few dependencies:

  %ul
    %li on version <code>3.0.0.rc</code> of <code>rails</code>
    %li on any version of <code>rack-cache</code>
    %li on a version of <code>nokogiri</code> that is <code>>= 1.4.2</code> but <code>< 1.5.0</code>

  %p
    After declaring your first set of dependencies, you tell bundler to go get them:

  :highlight_plain
    $ bundle install    # <code>bundle</code> is a shortcut for <code>bundle install</code>

  %p
    Bundler will connect to <code>rubygems.org</code> (and any other sources that you declared),
    and find a list of all of the required gems that meet the requirements you specified. Because
    all of the gems in your <code>Gemfile</code> have dependencies of their own (and some of
    those have their own dependencies), running <code>bundle install</code> on the
    <code>Gemfile</code> above will install quite a few gems.

  :highlight_plain
    $ bundle install
    Fetching source index for http://gemcutter.org/
    Using rake (0.8.7)
    Using abstract (1.0.0)
    Installing activesupport (3.0.0.rc)
    Using builder (2.1.2)
    Using i18n (0.4.1)
    Installing activemodel (3.0.0.rc)
    Using erubis (2.6.6)
    Using rack (1.2.1)
    Installing rack-mount (0.6.9)
    Using rack-test (0.5.4)
    Using tzinfo (0.3.22)
    Installing actionpack (3.0.0.rc)
    Using mime-types (1.16)
    Using polyglot (0.3.1)
    Using treetop (1.4.8)
    Using mail (2.2.5)
    Installing actionmailer (3.0.0.rc)
    Using arel (0.4.0)
    Installing activerecord (3.0.0.rc)
    Installing activeresource (3.0.0.rc)
    Using bundler (1.0.0.rc.3)
    Installing nokogiri (1.4.3.1) with native extensions
    Installing rack-cache (0.5.2)
    Installing thor (0.14.0)
    Installing railties (3.0.0.rc)
    Installing rails (3.0.0.rc)
    Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.

  %p
    If any of the needed gems are already installed, Bundler will use them. After installing
    any needed gems to your system, bundler writes a snapshot of all of the gems and
    versions that it installed to <code>Gemfile.lock</code>.

  %h2#updating-a-dependency
    Updating a Dependency

  %p
    Of course, at some point, you might want to update the version of a particular
    dependency your application relies on. For instance, you might want to update
    <code>rails</code> to <code>3.0.0</code> final. Importantly, just because you're
    updating one dependency, it doesn't mean you want to re-resolve all of your dependencies
    and use the latest version of everything. In our example, you only have three
    dependencies, but even in this case, updating everything can cause complications.

  %p
    To illustrate, the <code>rails 3.0.0.rc</code> gem depends on <code>actionpack
    3.0.0.rc</code> gem, which depends on <code>rack ~> 1.2.1</code> (which means <code>>=
    1.2.1</code> and <code>< 1.3.0</code>). The <code>rack-cache</code> gem depends on
    <code>rack >= 0.4</code>. Let's assume that the <code>rails 3.0.0</code> final gem also
    depends on <code>rack ~> 1.2.1</code>, and that since the release of <code>rails
    3.0.0</code>, the Rack team released <code>rack 1.2.2</code>.

  %p
    If we na√Øvely update all of our gems in order to update Rails, we'll get <code>rack
    1.2.2</code>, which satisfies the requirements of both <code>rails 3.0.0</code> and
    <code>rack-cache</code>. However, we didn't specifically ask to update
    <code>rack-cache</code>, which may not be compatible with <code>rack 1.2.2</code> (for
    whatever reason). And while an update from <code>rack 1.2.1</code> to <code>rack
    1.2.2</code> probably won't break anything, similar scenarios can happen that involve
    much larger jumps. (see [1] below for a larger discussion)

  %p
    In order to avoid this problem, when you update a gem, bundler will not update a
    dependency of that gem if another gem still depends on it. In this example, since
    <code>rack-cache</code> still depends on <code>rack</code>, bundler will not update the
    <code>rack</code> gem. This ensures that updating <code>rails</code> doesn't
    inadvertently break <code>rack-cache</code>. Since <code>rails 3.0.0</code>'s dependency
    <code>actionpack 3.0.0</code> remains compatible with <code>rack 1.2.1</code>, bundler
    leaves it alone, and <code>rack-cache</code> continues to work even in the face of an
    incompatibility with <code>rack 1.2.2</code>.

  %p
    Since you originally declared a dependency on <code>rails 3.0.0.rc</code>, if you want
    to update to <code>rails 3.0.0</code>, simply update your <code>Gemfile</code> to
    <code>gem 'rails', '3.0.0'</code> and run:

  :highlight_plain
    $ bundle install

  %p
    As described above, the <code>bundle install</code> command always does a conservative
    update, refusing to update gems (or their dependencies) that you have not explicitly
    changed in the <code>Gemfile</code>. This means that if you do not modify
    <code>rack-cache</code> in your <code>Gemfile</code>, bundler will treat it **and its
    dependencies** (<code>rack</code>) as a single, unmodifiable unit. If <code>rails
    3.0.0</code> was incompatible with <code>rack-cache</code>, bundler will report a
    conflict between your snapshotted dependencies (<code>Gemfile.lock</code>) and your
    updated <code>Gemfile</code>.

  %p
    If you update your <code>Gemfile</code>, and your system already has all of the needed
    dependencies, bundler will transparently update the <code>Gemfile.lock</code> when you
    boot your application. For instance, if you add <code>mysql</code> to your
    <code>Gemfile</code>, and have already installed it in your system, you can boot your
    application without running <code>bundle install</code>, and bundler will persist the
    "last known good" configuration to the <code>Gemfile.lock</code> snapshot.

  %p
    This can come in handy when adding or updating gems with minimal dependencies (database
    drivers, <code>wirble</code>, <code>ruby-debug</code>). It will probably fail if you
    update gems with significant dependencies (<code>rails</code>), or that a lot of gems
    depend on (<code>rack</code>). If a transparent update fails, your application will fail
    to boot, and bundler will print out an error instructing you to run <code>bundle
    install</code>.

  %h2#updating-a-gem-without-modyfying-the-gemfile
    Updating a Gem Without Modifying the Gemfile

  %p
    Sometimes, you want to update a dependency without modifying the Gemfile. For example,
    you might want to update to the latest version of <code>rack-cache</code>. Because you
    did not declare a specific version of <code>rack-cache</code> in the
    <code>Gemfile</code>, you might want to periodically get the latest version of
    <code>rack-cache</code>. To do this, you want to use the <code>bundle update</code>
    command:

  :highlight_plain
    $ bundle update rack-cache

  %p
    This command will update <code>rack-cache</code> and its dependencies to the latest
    version allowed by the <code>Gemfile</code> (in this case, the latest version
    available). It will not modify any other dependencies.

  %p
    It will, however, update dependencies of other gems if necessary. For instance, if the
    latest version of <code>rack-cache</code> specifies a dependency on <code>rack >=
    1.2.2</code>, bundler will update <code>rack</code> to <code>1.2.2</code> even though
    you have not asked bundler to update <code>rack</code>. If bundler needs to update a
    gem that another gem depends on, it will let you know after the update has completed.

  %p
    If you want to update every gem in the Gemfile to the latest possible versions, run:

  :highlight_plain
    $ bundle update

  %p
    This will resolve dependencies from scratch, ignoring the <code>Gemfile.lock</code>. If
    you do this, keep <code>git reset --hard</code> and your test suite in your back pocket.
    Resolving all dependencies from scratch can have surprising results, especially if a
    number of the third-party packages you depend on have released new versions since you
    last did a full update.

  %h2#deploying-your-application
    Deploying Your Application

  %p
    When you run <code>bundle install</code>, bundler will (by default), install your gems
    to your system repository of gems. This means that they will show up in <code>gem
    list</code>. Additionally, if you are developing a number of applications, you will not
    need to download and install gems in common for each application. This is nice for
    development, but somewhat problematic for deployment.

  %p
    In a deployment scenario, the Unix user you deploy with may not have access to install
    gems to a system location. Even if the user does (or you use <code>sudo</code>), the
    user that boots the application may not have access to them. For instance, Passenger
    runs its Ruby subprocesses with the user <code>nobody</code>, a somewhat restricted
    user. The tradeoffs in a deployment environment lean more heavily in favor of isolation
    (even at the cost of a somewhat slower deploy-time <code>bundle install</code> when some
    third-party dependencies have changed).

  %p
    As a result, bundler comes with a <code>--deployment</code> flag that encapsulates the
    best practices for using bundler in a deployment environment. These practices are based
    on significant feedback we have received during the development of bundler, as well as a
    number of bug reports that mostly reflected a misunderstanding of how to best configure
    bundler for deployment. The <code>--deployment</code> flags adds the following defaults:

  %ul
    %li
      Instead of installing gems to the system location, bundler will install gems to
      <code>vendor/bundle</code> inside your application. Bundler will transparently remember
      this location when you invoke it inside your application (with
      <code>Bundler.setup</code> and <code>Bundler.require</code>).
    %li
      Bundler will not use gems already installed to your system, even if they exist.
    %li
      If you have run <code>bundle pack</code>, checked in the <code>vendor/cache</code>
      directory, and do not have any git gems, Bundler will not contact the internet while
      installing your bundle.
    %li
      Bundler will require a <code>Gemfile.lock</code> snapshot, and fail if you did not
      provide one.
    %li
      Bundler will not transparently update your <code>Gemfile.lock</code> if it is out of
      date with your <code>Gemfile</code>

  %p
    If you use Capistrano, you should symlink <code>vendor/bundle</code> to
    <code>shared/vendor_bundle</code> so that bundler will share your installed gems between
    deployments (making things zippy if you didn't make any changes), but still give you the
    benefits of isolation from other applications.

  %p
    By defaulting the bundle directory to <code>vendor/bundle</code>, and installing your
    bundle as part of your deployment process, you can be sure that the same Unix user that
    checked out your application also installed the third-party code your application needs.
    This means that if Passenger (or Unicorn) can see your application, it can also see its
    dependencies.

  %p
    The <code>--deployment</code> flag requires an up-to-date <code>Gemfile.lock</code> to
    ensure that the testing you have done (in development and staging) actually reflects the
    code you put into production. You can run <code>bundle check</code> before deploying
    your application to make sure that your <code>Gemfile.lock</code> is up-to-date. Note
    that it will always be up-to-date if you have run <code>bundle install</code>,
    successfully booted your application (or run your tests) since the last time you changed
    your <code>Gemfile</code>.

  %h2#notes
    Notes

  %p
    [1] For instance, if <code>rails 3.0.0</code> depended on <code>rack 2.0</code>, that
    gem would still satisfy the requirement of <code>rack-cache</code>, which declares
    <code>>= 1.0</code> as a dependency. Of course, you could argue that
    <code>rack-cache</code> is silly for depending on open-ended versions, but these
    situations exist (extensively) in the wild, and projects often find themselves between a
    rock and a hard place when deciding what version to depend on. Constrain the dependency
    too much (<code>rack =1.2.1</code>) and you make it hard to use your project in other
    compatible projects. Constrain it too little (<code>rack >= 1.0</code>) and a new
    release of Rack may break your code. Using dependencies like <code>rack ~> 1.2.1</code>
    and versioning code in a SemVer compliant way mostly solves this problem, but it assumes
    universal compliance. Since Rubygems has over 100,000 packages, this assumption simply
    doesn't hold in practice.

